/* This file contains all the code needed to initialise CosGraphLabs.

    Written by Georgina Liversidge under the supervision of Marston Conder,
    for her PhD thesis in Mathematics at the University of Auckland, 2023.

    CosGraphLabs is a function for creating a labelled coset graph of a
    given subgroup H (generated by Hgens1) in a group G. The labelled coset graph
    can be used to obtain a presentation for the subgroup (reWrite2) or 
    find an expression for any element of H in terms of the elements in Hgens1
*/
/*Universal variables*/
    alph:="abcdefghijklmnopqrstuvwxyz";//lower case letters
    ALPH:="ABCDEFGHIJKLMNOPQRSTUVWXYZ";//upper case letters
    digs:="1234567890";//digits as strings
    ws:=[" ","\t", "\n","\r"];//white space characters
/*Universal variables*/

/*Basic functions*/
    /*labInv (label inverse)
        returns the inverse of label. label should be an array of integers. 
        The value returned will be an array of integers*/
    labInv:=function(label)
        label2:=[];//return value
        i:=#label;//index in label
        while i gt 0 do
            Append(~label2,-label[i]);
            i-:=1;
        end while;
        return label2;
    end function;

    /*LabE (Label Edge) 
        updates labels with the given data.*/
    LabE:=procedure(~labels,ctb,p,i,label, gens, invs, ~newLabs, ~numLabd)
        labels[p, i]:=label;//add label to table
        q:=ctb(p, gens[i]);
        labels[q, invs[i]]:=labInv(label);//add in inverse postion
        Append(~newLabs, [p,i]);//we only need to add one of the new labels
        numLabd+:=1;
    end procedure;

    /*simpCat (simplified catonation)
        returns the simplified catonation of lab1 and lab2. 
        It is assumed that lab1 and lab2 are simplified already*/
    simpCat:=function(lab1, lab2)
        i:=1;
        while i le #lab1 and i le #lab2 do
            if lab1[#lab1 + 1 -i] eq -lab2[i] then//continue
                i+:=1;
            else//no more inverse pairs at pt of catonation
                break;
            end if;
        end while;
        if i gt #lab1 then//all of lab1 cancelled
            if i gt #lab2 then//all of lab2 cancelled
                return [];
            else
                return lab2[i..#lab2];
            end if;
        elif i gt #lab2 then//all of lab2 cancelled
            return lab1[1..(#lab1+1-i)];
        else
            return lab1[1..(#lab1+1-i)] cat lab2[i..#lab2];
        end if;
    end function;

    /*readWrd (read word)
        traces word (an array of integers) around the coset table ctb from coset p.
        returns a simplified catonation of the labels corresponding to the 
        edges used.*/
    readWrd:=function(word, labels, ctb, gens, p)
        point:=p;//current coset
        label:=[];//return value
        for i in word do
            label:=simpCat(label,labels[point, i]);//add label
            point:=ctb(point,gens[i]);//move to next point
        end for;
        return label;
    end function;

    /*readWrd2 (read word version 2)
        same as read word except no simplification
        also returns a list of zero edges in the form [c1, g, c2]
        this function is used if the procedure is unable to produce
        a labelled coset graph. This information may be useful
        to the user to complete the labelling by hand*/
    readWrd2:=function(word, labels, ctb, gens, p)
        point:=p;//current coset
        label:=[];//return value 1
        zedges:=[];//zero edges
        for i in word do
            label cat:=labels[point, i];//add label
            if labels[point, i] eq [0] then//add zero edge
                Append(~zedges, [point,i,ctb(point,gens[i])]);
            end if;
            point:=ctb(point,gens[i]);//move to next point
        end for;
        return label, zedges;
    end function;

    /*getLab (get label)
        read the word from coset p. return the coset and generator of the zero edge
        and the label for this edge. lab contains the label which we want this word 
        to simplify to. Eg [] if word is a relation or [i] for Hgen[i]*/
    getLab:=function(word, labels, ctb, gens, p, lab)
        v:=0;//vertex of zero edge
        g:=0;//generator of zero edge
        label1:=[];//1st half
        label2:=[];//2nd half
        i:=1;//index in word
        while i le #word do//find first half
            if labels[p, word[i]] eq [0] then//store point
                v:=p;
                g:=word[i];
                p:=ctb(p,gens[word[i]]);//move to next point
                i+:=1;
                break;
            end if;
            //else
            label1:=simpCat(label1,labels[p, word[i]]);//add label
            p:=ctb(p,gens[word[i]]);//move to next point
            i+:=1;
        end while;
        while i le #word do//find second half
            label2:=simpCat(label2,labels[p, word[i]]);//add label
            p:=ctb(p,gens[word[i]]);//move to next point
            i+:=1;
        end while;
        label:=simpCat(simpCat(labInv(label1), lab), labInv(label2));
        return [*v, g, label*];
    end function;

    /*testLab (test label)
        tests for appearances of t and -t for t gt n in label.
        returns 0 for no appearances
        returns 1 for a single appearance
        returns 2 for 2 or more appearances
        the second return value is the index of the first appearance*/
    testLab:=function(label, n)
        i:=1;//index in label
        v:=0;//stores index of first appearance
        while i le #label do//find first appearance
            if label[i] gt n or -label[i] gt n then
                v:=i;//assign index
                break;                
            end if;
            i+:=1;
        end while;
        if i gt #label then//no appearances
            return [0,v];
        end if;
        i+:=1;
        while i le #label do//check for second appearance
            if label[i] gt n or -label[i] gt n then
                return [2, v];
            end if;
            i+:=1;
        end while;
        return [1,v];//if here, then only one appearance
    end function;

    /*testLab2 (test label version 2)
        tests for appearances of t and -t for t gt n in label.
        returns a set of t's which appear only once*/
    testLab2:=function(label, n)
        i:=1;//index in label
        s1:=[];//stores labels found once (so far)
        s2:=[];//store labels found 2 or more times 
        while i le #label do//find first appearance
            if Abs(label[i]) gt n then //temp gen found
                if Abs(label[i]) in s1 then//move to s2
                    Exclude(~s1, Abs(label[i]));
                    Append(~s2, Abs(label[i]));
                elif Abs(label[i]) notin s2 then//add to s1
                    Append(~s1, Abs(label[i]));
                //else in s2, do nothing
                end if;
            end if;
            i+:=1;
        end while;
        return s1;
    end function;

    /*repTemp (replace temporary generator)
        replace each appearance of t in lab1 with lab2 and 
        each appearance of -t with lab3*/
    repTemp:=function(lab1, t, lab2, lab3)
        i:=1;//index in lab1
        while i le #lab1 do
            if lab1[i] eq t then//temp gen found
                lab1:=simpCat(lab1[1..(i-1)], simpCat(lab2, lab1[(i+1)..#lab1]));
                i:=1;// no telling how much cancelling has occured
            elif lab1[i] eq -t then//inverse found
                lab1:=simpCat(lab1[1..(i-1)], simpCat(lab3, lab1[(i+1)..#lab1]));
                i:=1;// no telling how much cancelling has occured
            else
                i+:=1;//continue
            end if;
        end while;
        return lab1;
    end function;

    /*writeWrd (write word)
        given a word rel in G, returns an array of the elements as integers, 
        corresponding to their position in the array gens. 
        gens should contain inverses and is used to identify the column of 
        the coset table etc*/
    writeWrd:=function(rel, gens, invs, G);
        word:=[];//return value
        while rel ne Id(G) do
            for gen in [1..#gens] do//gens contains inverses as well
                if gens[gen]*rel lt rel then
                    Append(~word, invs[gen]);//add to word
                    rel:=gens[gen]*rel;//remove from rel
                end if;
            end for;
        end while;	
        return word;
    end function;

    /*cycTest (cyclic test)
        returns false if g, its rotations or their inverses appear in L*/
    cycTest:=function(L, g);
        if g in L then
            return false;
        end if;
        for i in [2..#g] do//test rotations
            if g[i..#g] cat g[1..(i-1)] in L then
                return false;
            end if;
        end for;
        g:=labInv(g);//invert
        if g in L then
            return false;
        end if;
        for i in [2..#g] do//test rotations
            if g[i..#g] cat g[1..(i-1)] in L then
                return false;
            end if;
        end for;
        return true;//all tests passed
    end function;
/*end basic functions*/

/*labelling coset graph*/

    /*appRel (apply relation)
        apply the relation rel to the coset cos. If there is a single 
        unlabelled edge then solve to label this edge*/
    appRel:=procedure(cos, rel, lab, ~labels, ~numLabd, ~newLabs, ctb, gens, invs)
        j:=1;//index
        p:=cos;//current coset
        cnt:=0;//number of zero edges
        while j le #rel and cnt lt 2 do//count number of zeroes
            if labels[p,rel[j]] eq [0] then//zero edge found
                cnt+:=1;
            end if;
            p:=ctb(p,gens[rel[j]]);//next vertex/coset
            j+:=1;
        end while;
        if cnt eq 1 then//label edge
            temp:=getLab(rel, labels, ctb, gens, cos, lab);//get label info
            LabE(~labels,ctb,temp[1],temp[2],temp[3], gens, invs, 
                ~newLabs, ~numLabd);//update
        end if;	
    end procedure;

    /*tempRfill (add temporary generators to fill relations)
        tests each relation identified in cvd[v] from coset v, for each coset v.
        If there are M+1 unlabelled edges then add a temporary label to M of them, 
        and solve to get the other.
        then apply rels until no more changes are made or a new label not 
        containing the temporary generators is found. If such a label is found, 
        then it is returned.*/
    tempRfill:=function(labels, numLabd, cvd, ctb, relwords, gens, 
        invs, cycRels, newLabs, UnLabd, Hgens, M)
        for v1 in [1..#ctb] do
            for i in cvd[v1] do//check each relation
                word:=relwords[i];
                j:=1;//index in word
                cnt:=0;//number of zero edges
                p:=v1;//current coset
                while j le #word and cnt le M+1 do//count zeroes up to M+2
                    if labels[p, word[j]] eq [0] then//zero edge found
                        cnt+:=1;
                    end if;
                    p:=ctb(p, gens[word[j]]);//next coset
                    j+:=1;
                end while;
                if cnt eq M+1 then//label edges with tempGens
                    labels2:=labels;//copy to try out new tempGens
                    numLabd2:=numLabd;//needed for labE
                    newLabs2:=[];//new labels in labels2
                    UnLabd2:=UnLabd;//copy to try out tempGens
                    j:=1;//index in word
                    cnt:=0;//number of zero edges (so far)
                    p:=v1;//current coset
                    edges:=[];//list of zero edges
                    while j le #word do//get zero edges
                        if labels[p, word[j]] eq [0] then
                            if cnt eq 0 then//skip first 0
                                cnt+:=1;
                                Append(~edges, [p,word[j]]);
                            else
                                LabE(~labels2,ctb,p,word[j],[#Hgens +cnt], 
                                    gens, invs, ~newLabs2, ~numLabd2);
                                Append(~edges, [p,word[j]]);
                                cnt+:=1;
                            end if;
                        end if;
                        p:=ctb(p, gens[word[j]]);//next coset
                        j+:=1;
                    end while;
                    //solve to label first zero edge
                    temp:=getLab(word, labels2, ctb, gens, v1, []);
                    if temp[1] ne 0 then
                        LabE(~labels2,ctb,temp[1], temp[2], temp[3], gens, invs, 
                            ~newLabs2, ~numLabd2);
                    //else repeated edge, already labelled
                    end if;
                    while #newLabs2 ne 0 do//update labels2
                        j:=1;
                        while j le #UnLabd2 do
                            k:=UnLabd2[j];//index in Hgens
                            cnt:=0;//number of zero labels
                            p:=1;//coset
                            x:=1;//index in Hgens[k]
                            while x le #Hgens[k] and cnt le 2 do//count zeroes
                                if labels2[p, Hgens[k][x]] eq [0] then
                                    cnt+:=1;
                                end if;
                                p:=ctb(p,gens[Hgens[k][x]]);//go to next coset
                                x+:=1;
                            end while;
                            if cnt eq 0 then//could give label for a tempGen
                                label:=readWrd(Hgens[k], labels2, ctb, gens, 1);
                                t:=testLab(label, #Hgens);
                                //test if contains tempgens
                                if t[1] eq 1 then
                                //can rearrange to get word for tempGen
                                    label2:=simpCat(labInv(label[1..(t[2]-1)]), 
                                        [k] cat labInv(label[(t[2]+1)..#label]));
                                    if label[t[2]] lt 0 then//invert
                                        label2:=labInv(label2);
                                        tempGen:=-label[t[2]];
                                    else
                                        tempGen:=label[t[2]];
                                    end if;
                                    return [*edges[tempGen-#Hgens+1][1], 
                                        edges[tempGen-#Hgens+1][2],label2*];
                                else
                                    Remove(~UnLabd2, j);
                                    j-:=1; //1 will be added later
                                end if;
                            elif cnt eq 1 then//label edge
                                label:=readWrd(Hgens[k], labels2, ctb, gens, 1);
                                temp:=testLab(label, #Hgens);
                                t:=getLab(Hgens[k], labels2, ctb, gens, 1, [k]);
                                //test if contains tempgens
                                if temp[1] eq 0 then//no tempGens, add to labels
                                    return t;
                                else//add to labels 2
                                    LabE(~labels2,ctb, t[1], t[2], t[3], gens, 
                                        invs, ~newLabs2, ~numLabd2);
                                    Remove(~UnLabd2, j);
                                    j:=0;//restart testing UnLabd
                                end if;
                            end if;	
                            j+:=1;
                        end while;
                        cos:=newLabs2[1][1];
                        g:=newLabs2[1][2];
                        Remove(~newLabs2,1);
                        for rel in cycRels[g] do//test each rel in list
                            cnt:=0;//number of zero labels
                            p:=cos;//coset
                            x:=1;//index
                            while x le #rel and cnt le 2 do//count zeroes
                                if labels2[p, rel[x]] eq [0] then
                                    cnt+:=1;
                                end if;
                                p:=ctb(p,gens[rel[x]]);//go to next coset
                                x+:=1;
                            end while;
                            if cnt eq 0 then//could give label for a tempGen
                                label:=readWrd(rel, labels2, ctb, gens, cos);
                                t:=testLab(label, #Hgens);
                                //test if contains tempgens
                                if t[1] eq 1 then
                                //can rearrange to get word for tempGen
                                    label2:=simpCat(labInv(label[1..(t[2]-1)]), 
                                        labInv(label[(t[2]+1)..#label]));
                                    if label[t[2]] lt 0 then//invert
                                        label2:=labInv(label2);
                                        tempGen:=-label[t[2]];
                                    else
                                        tempGen:=label[t[2]];
                                    end if;
                                    return[*edges[tempGen-#Hgens+1][1], 
                                        edges[tempGen-#Hgens+1][2],label2*];
                                end if;
                            elif cnt eq 1 then//label edge
                                label:=readWrd(rel, labels2, ctb, gens, cos);
                                temp:=testLab(label, #Hgens);
                                t:=getLab(rel, labels2, ctb, gens, cos, []);
                                //test if contains tempgens
                                if temp[1] eq 0 then//no tempGens, add to labels
                                    return t;
                                else//add to labels 2
                                    LabE(~labels2,ctb, t[1], t[2], t[3], gens, 
                                        invs, ~newLabs2, ~numLabd2);
                                end if;
                            end if;	
                        end for;
                    end while;
                end if;
            end for;
        end for;
        return [*0,0,[]*];//default return value
    end function;

    /*tempGfill (add temporary generators to fill generators)
        like tempRfill, but filling generators instead of relations*/
    tempGfill:=function(labels, numLabd, ctb, relwords, gens, 
        invs, cycRels, newLabs, UnLabd, Hgens, M)
        for i in UnLabd do//check each unlabelled Hgen
            word:=Hgens[i];
            j:=1;//index in word
            cnt:=0;//number of zero edges
            p:=1;//current coset
            while j le #word and cnt le M+1 do//count zeroes up to M+2
                if labels[p, word[j]] eq [0] then
                    cnt+:=1;
                end if;
                p:=ctb(p, gens[word[j]]);//next coset
                j+:=1;
            end while;
            if cnt eq M+1 then//label edges with tempGens
                labels2:=labels;//copy to try out new tempGens
                numLabd2:=numLabd;//for labE
                newLabs2:=[];//new labels in labels2
                UnLabd2:=UnLabd;//copy to try out tempgens
                j:=1;//index in word
                cnt:=0;//number of zero edges (so far)
                p:=1;//current coset
                edges:=[];//list of zero edges
                while j le #word do//get zero edges
                    if labels[p, word[j]] eq [0] then
                        if cnt eq 0 then//skip first 0
                            cnt+:=1;
                            Append(~edges, [p,word[j]]);
                        else
                            LabE(~labels2,ctb,p,word[j],[#Hgens +cnt], 
                                gens, invs, ~newLabs2, ~numLabd2);
                            Append(~edges, [p,word[j]]);
                            cnt+:=1;
                        end if;
                    end if;
                    p:=ctb(p, gens[word[j]]);//next coset
                    j+:=1;
                end while;
                //solve to label first zero edge
                temp:=getLab(word, labels2, ctb, gens, 1, [i]);
                if temp[1] ne 0 then
                    LabE(~labels2,ctb,temp[1], temp[2], temp[3], gens, invs, 
                        ~newLabs2, ~numLabd2);
                    Exclude(~UnLabd2, i);
                //else repeated edge, already labelled
                end if;
                while #newLabs2 ne 0 do//update labels2
                    j:=1;//index in UnLabd2
                    while j le #UnLabd2 do//test unlabelled Hgens
                        k:=UnLabd2[j];//index in Hgens
                        cnt:=0;//number of zero labels
                        p:=1;//coset
                        x:=1;//index in Hgens[k]
                        while x le #Hgens[k] and cnt le 2 do//count zeroes
                            if labels2[p, Hgens[k][x]] eq [0] then
                                cnt+:=1;
                            end if;
                            p:=ctb(p,gens[Hgens[k][x]]);//go to next coset
                            x+:=1;
                        end while;
                        if cnt eq 0 then//could give label for a tempGen
                            label:=readWrd(Hgens[k], labels2, ctb, gens, 1);
                            t:=testLab(label, #Hgens);
                            //test if contains tempgens
                            if t[1] eq 1 then
                            //can rearrange to get word for tempGen
                                label2:=simpCat(labInv(label[1..(t[2]-1)]), 
                                    [k] cat labInv(label[(t[2]+1)..#label]));
                                if label[t[2]] lt 0 then//invert
                                    label2:=labInv(label2);
                                    tempGen:=-label[t[2]];
                                else
                                    tempGen:=label[t[2]];
                                end if;
                                return[*edges[tempGen-#Hgens+1][1], 
                                    edges[tempGen-#Hgens+1][2],label2*];
                            else
                                Remove(~UnLabd2, j);
                                j-:=1;//1 will be added later
                            end if;
                        elif cnt eq 1 then//label edge
                            label:=readWrd(Hgens[k], labels2, ctb, gens, 1);
                            temp:=testLab(label, #Hgens);
                            t:=getLab(Hgens[k], labels2, ctb, gens, 1, [k]);
                            //test if contains tempgens
                            if temp[1] eq 0 then//no tempGens, add to labels
                                return t;
                            else//add to labels 2
                                LabE(~labels2,ctb, t[1], t[2], t[3], gens, 
                                    invs, ~newLabs2, ~numLabd2);
                                Remove(~UnLabd2, j);
                                j:=0;//restart
                            end if;
                        end if;	
                        j+:=1;
                    end while;
                    cos:=newLabs2[1][1];
                    g:=newLabs2[1][2];
                    Remove(~newLabs2,1);
                    for rel in cycRels[g] do//test each rel in list
                        cnt:=0;//number of zero labels
                        p:=cos;//coset
                        x:=1;//index in rel
                        while x le #rel and cnt le 2 do//count zeroes
                            if labels2[p, rel[x]] eq [0] then
                                cnt+:=1;
                            end if;
                            p:=ctb(p,gens[rel[x]]);//go to next coset
                            x+:=1;
                        end while;
                        if cnt eq 0 then//could give label for a tempGen
                            label:=readWrd(rel, labels2, ctb, gens, cos);
                            t:=testLab(label, #Hgens);
                            //test if contains tempgens
                            if t[1] eq 1 then
                                //can rearrange to get word for tempGen
                                label2:=simpCat(labInv(label[1..(t[2]-1)]), 
                                    labInv(label[(t[2]+1)..#label]));
                                if label[t[2]] lt 0 then//invert
                                    label2:=labInv(label2);
                                    tempGen:=-label[t[2]];
                                else
                                    tempGen:=label[t[2]];
                                end if;
                                return [*edges[tempGen-#Hgens+1][1], 
                                    edges[tempGen-#Hgens+1][2],label2*];
                            end if;
                        elif cnt eq 1 then//label edge
                            label:=readWrd(rel, labels2, ctb, gens, cos);
                            temp:=testLab(label, #Hgens);
                            t:=getLab(rel, labels2, ctb, gens, cos, []);
                            //test if contains tempgens
                            if temp[1] eq 0 then//no tempGens, add to labels
                                return t;
                            else//add to labels 2
                                LabE(~labels2,ctb, t[1], t[2], t[3], gens, 
                                    invs, ~newLabs2, ~numLabd2);
                            end if;
                        end if;	
                    end for;
                end while;
            end if;
        end for;
        return [*0,0,[]*];//default return value
    end function;

    /*addTemps (add temporary generators)
        like tempRfill except just systematically go through all sets 
        of unlabelled edges of size M,
        if a label is found then it's coordinates and the label are returned
        else [0,0,[]] is returned*/
    addTemps:=function(labels, numLabd, ctb, relwords, gens, 
        invs, cycRels, newLabs, UnLabd, Hgens, M)
        //print "running addTemps with M=", M;
        //set up initial set of edges
        m:=Floor(#gens/2);// actual number of generators in G
        c1:=1;//current coset
        edges:=[];//edge set
        while #edges lt M and c1 le #ctb do
            for g in [1..m] do
                if labels[c1, g] eq [0] then
                    Append(~edges, [c1,g]);
                    if #edges eq M then 
                        break;
                    end if;
                end if;
            end for;
            c1+:=1;
        end while;
        if #edges eq M then
            flag:=true;
        else//not enough unlabelled edges
            return [*0, 0, []*];
        end if;
        while flag do
            labels2:=labels;//copy to try out new tempGens
            numLabd2:=numLabd;//for labE
            newLabs2:=[];//new labels in labels2
            UnLabd2:=UnLabd;//copy to try out tempGens
            cnt:=1;//number of zero edges (so far)
            for edge in edges do//label edges
                LabE(~labels2,ctb,edge[1],edge[2],[#Hgens +cnt], 
                    gens, invs, ~newLabs2, ~numLabd2);
                cnt+:=1;
            end for;
            while #newLabs2 ne 0 do//update labels2
                cos:=newLabs2[1][1];
                g:=newLabs2[1][2];
                Remove(~newLabs2,1);
                for rel in cycRels[g] do//test each rel in list
                    cnt:=0;//number of zero labels
                    p:=cos;//current coset
                    x:=1;//index in rel
                    while x le #rel and cnt le 2 do//count zeroes
                        if labels2[p, rel[x]] eq [0] then
                            cnt+:=1;
                        end if;
                        p:=ctb(p,gens[rel[x]]);//go to next coset
                        x+:=1;
                    end while;
                    if cnt eq 0 then//could give label for a tempGen
                        label:=readWrd(rel, labels2, ctb, gens, cos);
                        t:=testLab(label, #Hgens);
                        //test if contains tempgens
                        if t[1] eq 1 then
                        //can rearrange to get word for tempGen
                            label2:=simpCat(labInv(label[1..(t[2]-1)]), 
                                labInv(label[(t[2]+1)..#label]));
                            if label[t[2]] lt 0 then//invert
                                label2:=labInv(label2);
                                tempGen:=-label[t[2]];
                            else
                                tempGen:=label[t[2]];
                            end if;
                            return [*edges[tempGen-#Hgens][1], 
                                edges[tempGen-#Hgens][2],label2*];
                        end if;
                        s1:=testLab2(label, #Hgens);
                        if #s1 gt 0 then
                        //use to remove a tempGen
                            ind:=Index(label, s1[1]);
                            if ind eq 0 then//negative appearance
                                ind:=Index(label, -s1[1]);
                            end if;
                            lab2:=simpCat(labInv(label[1..ind-1]),
                                labInv(label[ind+1..#label]));//label for s1[1]
                            if label[ind] lt 0 then
                                lab3:=lab2;//inverse label
                                lab2:=labInv(lab2);
                            else
                                lab3:=labInv(lab2);//inverse label
                            end if;
                            //now replace s1[1] with lab2 and -s1[1] with lab3
                            for c1 in [1..#ctb] do
                                for r1 in [1..#gens] do
                                    if s1[1] in labels2[c1, r1] or 
                                        -s1[1] in labels2[c1, r1] then
                                        tlab:=repTemp(labels2[c1, r1], s1[1], lab2, lab3);
                                        temp:=testLab(tlab, #Hgens);
                                        if temp[1] eq 0 then
                                            return [*c1, r1, tlab*];
                                        else
                                            labels2[c1, r1]:=tlab;
                                        end if;
                                    end if;
                                end for;
                            end for;
                        end if;
                    elif cnt eq 1 then//label edge
                        label:=readWrd(rel, labels2, ctb, gens, cos);
                        temp:=testLab(label, #Hgens);
                        t:=getLab(rel, labels2, ctb, gens, cos, []);
                        //test if contains tempgens
                        if temp[1] eq 0 then//no tempGens, add to labels
                            return t;
                        else//add to labels 2
                            LabE(~labels2,ctb, t[1], t[2], t[3], gens, 
                                invs, ~newLabs2, ~numLabd2);
                        end if;
                    end if;	
                end for;
                j:=1;
                while j le #UnLabd2 do//apply unlabelled Hgens
                    i:=UnLabd2[j];//index in Hgens
                    cnt:=0;//number of zero labels
                    p:=1;//current coset
                    x:=1;//index in Hgens[i]
                    while x le #Hgens[i] and cnt le 2 do//count zeroes
                        if labels2[p, Hgens[i][x]] eq [0] then
                            cnt+:=1;
                        end if;
                        p:=ctb(p,gens[Hgens[i][x]]);//go to next coset
                        x+:=1;
                    end while;
                    if cnt eq 0 then//could give label for a tempGen
                        label:=readWrd(Hgens[i], labels2, ctb, gens, 1);
                        t:=testLab(label, #Hgens);//test if contains tempgens
                        if t[1] eq 1 then
                        //can rearrange to get word for tempGen
                            label2:=simpCat(labInv(label[1..(t[2]-1)]), 
                                [i] cat labInv(label[(t[2]+1)..#label]));
                            if label[t[2]] lt 0 then//invert
                                label2:=labInv(label2);
                                tempGen:=-label[t[2]];
                            else
                                tempGen:=label[t[2]];
                            end if;
                            return [*edges[tempGen-#Hgens][1], 
                                edges[tempGen-#Hgens][2],label2*];
                        end if;
                        s1:=testLab2(label, #Hgens);
                        if #s1 gt 0 then
                        //use to remove a tempGen
                            ind:=Index(label, s1[1]);
                            if ind eq 0 then//negative appearance
                                ind:=Index(label, -s1[1]);
                            end if;
                            lab2:=labInv(label[1..ind-1]) cat [j]
                                cat labInv(label[ind+1..#label]);//label for s1[1]
                            if label[ind] lt 0 then
                                lab3:=lab2;//inverse
                                lab2:=labInv(lab2);
                            else
                                lab3:=labInv(lab2);//inverse
                            end if;
                            //now replace s1[1] with lab2 and -s1[1] with lab3
                            for c1 in [1..#ctb] do
                                for r1 in [1..#gens] do
                                    if s1[1] in labels2[c1, r1] or
                                        -s1[1] in labels2[c1, r1] then
                                        tlab:=repTemp(labels2[c1, r1], s1[1], 
                                            lab2, lab3);
                                        temp:=testLab(tlab, #Hgens);
                                        if temp[1] eq 0 then
                                            return [*c1, r1, tlab*];
                                        else
                                            labels2[c1, r1]:=tlab;
                                        end if;
                                    end if;
                                end for;
                            end for;
                        end if;
                        Remove(~UnLabd2, j);
                        j-:=1;//1 added later
                    elif cnt eq 1 then//label edge
                        label:=readWrd(Hgens[i], labels2, ctb, gens, 1);
                        temp:=testLab(label, #Hgens);
                        t:=getLab(Hgens[i], labels2, ctb, gens, 1, [i]);
                        //test if contains tempgens
                        if temp[1] eq 0 then//edge found
                            return t;
                        else//add to labels 2
                            LabE(~labels2,ctb, t[1], t[2], t[3], gens, 
                                invs, ~newLabs2, ~numLabd2);
                            Remove(~UnLabd2, j);
                            j:=0;
                        end if;
                    end if;	
                    j+:=1;
                end while;
            end while;
            //update set
            flag:=false;//true once new set is found
            c1:=edges[M,1];//last edge added
            g:=edges[M,2]+1;
            Prune(~edges);//remove last edge
            while #edges lt M do
                while c1 le #ctb do
                    while g le m do
                        if labels[c1,g] eq [0] then
                            Append(~edges, [c1,g]);
                            if #edges eq M then//finished
                                flag:=true;
                                c1:=#ctb+1;
                                g:=m+1;//breaks loop
                            end if;
                        end if;
                        g+:=1;
                    end while;
                    c1+:=1;
                    g:=1;
                end while;
                if not(flag) and #edges ge 1 then//remove previous edge
                    c1:=edges[#edges,1];
                    g:=edges[#edges,2]+1;
                    Prune(~edges);
                else
                    break;
                end if;
            end while;
        end while;
        return [*0, 0, []*];//default return
    end function;
/*end labelling functions*/

/*User functions*/
    /*CosGraphLabs (coset graph labels)
        declaration of variables
        ctb= the coset table
        indH= the index of H in G
        gens= the generators of G(and their inverses), as used in ctb
        invs= gives a the index of the inverse of the generators in gens
        relwords= the relations of G
        we will label the edges of the spanning tree with sequences of the 
        integers 0..#Hgens.
        0 will be used to represent an unlabelled edge, 
        while an edge which is equal to the identity will have an empty sequence.
        The integers 1..#Hgens correspond to the generators of H*/

    CosGraphLabs:=function(G, Hgens1)
        start:=Realtime();	
        //set up
            Grels:=[LHS(w)*RHS(w)^-1 : w in Relations(G)];
            H:=sub<G|Hgens1>;
            ctb:=CosetTable(G,H); 
            indH:=Index(G,H);
            if indH ne #ctb then//error
                print "Coset table incomplete";
                print "index=", indH;
                print "#ctb", #ctb;
                read str;
                return [], [];
            end if;
            //convert gens to array
            gens:=[];
            for gen in Generators(G) do
                Append(~gens, gen);
            end for;
            //add inverses
            for gen in Generators(G) do
                Append(~gens, gen^-1);
            end for;
            invs:=[(Ngens(G)+1)..(2*Ngens(G))] cat [1..Ngens(G)];
            //gives inverse column
            newLabs:=[];//new labels to be processed
            Hgens:=[];//formatted generators of H
            for wrd in Hgens1 do
                Append(~Hgens, writeWrd(wrd, gens, invs, G));
            end for;
            //create relwords
            relWrds:=[];
            for rel in Grels do
                Append(~relWrds, writeWrd(rel, gens, invs, G));
            end for;
            maxGFill:=1;//max M value for gfill
            for wrd in Hgens do
                if #wrd gt maxGFill then
                    maxGFill:=#wrd;
                end if;
            end for;
            maxRFill:=1;//max M value for rfill
            for wrd in relWrds do
                if #wrd gt maxRFill then
                    maxRFill:=#wrd;
                end if;
            end for;
            //set up tree
            numLabd:=0;//number of edges labelled
            labelrow:=[[0]:i in [1..2*Ngens(G)]];
            labels:=[labelrow : i in [1..indH]];//labels of edges
            tree:={1};//set of vertices covered in spanning tree
            //create cvd
            cvd:=[];//covered:relations which we need to test from vertex v
            for v in [1..indH] do
                cvd cat:=[[]];
            end for;
            //create relRepeats
            relRepeats:=[[]: i in [1..#relWrds]];
            for i in [1..#relWrds] do
                word:=relWrds[i];
                for j in [2..#word] do
                    Append(~word,word[1]);
                    Remove(~word, 1);
                    if word eq relWrds[i] then
                        Append(~relRepeats[i],j);
                    end if;
                end for;		
            end for;
            //now use relRepeats to update cvd
            for i in [1..#relWrds] do
                cvd2:={1..indH};
                j:=1;
                while j le indH do
                    if j in cvd2 then
                        cvd[j] cat:=[i];
                        p:=j;
                        verts:=[p];
                        for x in [1..#relWrds[i]] do
                            p:=ctb(p,gens[relWrds[i][x]]);//get next vertex
                            Append(~verts, p);//add to array
                        end for;
                        for k in relRepeats[i] do
                            Exclude(~cvd2,verts[k]);
                        end for;
                    end if;
                    j+:=1;
                end while;
            end for;
            //create cycRels for use in proc2
            cycRels:=[[]: i in [1..2*Ngens(G)]];
            for r1 in relWrds do
                Append(~cycRels[r1[1]], r1);//add original
                i:=1;//count rotations
                r2:=r1;//can't alter r1
                r3:=[];//inverse of r2
                for g in r1 do
                    Insert(~r3, 1, invs[g]);
                end for;
                if r3 notin cycRels[r3[1]] then
                    Append(~cycRels[r3[1]], r3);
                end if;
                while i le #r2-1 do
                    Insert(~r2, 1, r2[#r2]);//add last element to first position
                    Prune(~r2);//remove last element
                    if not(r2 in cycRels[r2[1]]) then
                        Append(~cycRels[r2[1]], r2);
                        Append(~r3, r3[1]);//add first element to last position
                        Remove(~r3,1);//remove first element
                        Append(~cycRels[r3[1]], r3);
                    else//reached repeat
                        break;
                    end if;
                    i+:=1;
                end while;
            end for;
        //systematically build the spanning tree.
            v:=1;
            while v le indH and #tree lt indH do
                for g in [1..2*Ngens(G)] do
                    v2:=ctb(v,gens[g]);
                    if not(v2 in tree) then//add to tree
                        LabE(~labels,ctb,v,g,[], gens, invs, ~newLabs, 
                            ~numLabd);
                        Include(~tree, v2);
                    end if;
                end for;
                v+:=1;//move to next vertex. 
                //note that it must already be in the tree
            end while;
            UnLabd:=[1..#Hgens];
        //use relations in rel words to label other edges
            if numLabd lt Ngens(G)*indH then
                flag:=true;
                while flag do 
                    //print "numLabd=", numLabd, "/", Ngens(G)*indH;
                    flag:=false;
                    numLabd2:=numLabd;
                    while #newLabs gt 0 do
                        cos:=newLabs[1][1];
                        g:=newLabs[1][2];
                        Remove(~newLabs, 1);
                        for rel in cycRels[g] do
                            appRel(cos, rel, [], ~labels, ~numLabd, ~newLabs, 
                                ctb, gens, invs);
                        end for;
                    end while;
                    if numLabd eq Ngens(G)*indH then//finished
                        break;
                    else//no changes but not finished
                        //try reprocessing Hgens
                        i:=1;
                        while i le #UnLabd do
                            appRel(1, Hgens[UnLabd[i]], [UnLabd[i]], ~labels, 
                                ~numLabd, ~newLabs, ctb, gens, invs);
                            if #newLabs gt 0 then//success
                                flag:=true;
                                Remove(~UnLabd, i);
                                i:=#UnLabd +1;//quit loop
                            else// double check not already labelled
                                cos:=1;
                                Zflag:=true;//true if no zeroes found
                                for g in Hgens[UnLabd[i]] do
                                    if labels[cos,g] eq [0] then
                                        Zflag:=false;
                                        break;
                                    end if;
                                    cos:=ctb(cos, gens[g]);
                                end for;
                                if Zflag then
                                    Remove(~UnLabd, i);
                                end if;
                            end if;
                            i+:=1;
                        end while;
                        if not(flag) then//update cvd
                            for v in [1..#ctb] do
                                cvdv:=cvd[v];//copy so we can edit original
                                for r in cvdv do
                                    c:=1;
                                    Zflag:=true;//true if no zeroes found
                                    for g in relWrds[r] do
                                        if labels[c,g] eq [0] then
                                            Zflag:=false;
                                            break;
                                        end if;
                                        c:=ctb(c, gens[g]);
                                    end for;
                                    if Zflag then
                                        Exclude(~cvd[v], r);
                                    end if;
                                end for;
                            end for;
                        end if;
                        //try adding tempGens
                        M:=1;
                        while not(flag) and M lt maxGFill do
                        //try smart fill option 1
                            t:=tempGfill(labels, numLabd, ctb, relWrds, gens,
                                invs, cycRels, newLabs, UnLabd, Hgens, M); 
                            if t[1] ne 0 then//success
                                if labels[t[1], t[2]] ne [0] then
                                    print "error with tempGfill";
                                    print "edge already labelled";
                                    read str;
                                end if;
                                flag:=true;
                                LabE(~labels,ctb,t[1], t[2], t[3], gens, invs, 
                                    ~newLabs, ~numLabd);
                            else
                                M+:=1;
                            end if;
                        end while; 
                        M:=1;
                        while not(flag) and M lt maxRFill do
                        //try smart fill option 2
                            t:=tempRfill(labels, numLabd, cvd, ctb, relWrds, gens,
                                invs, cycRels, newLabs, UnLabd, Hgens, M); 
                            if t[1] ne 0 then//success
                                if labels[t[1], t[2]] ne [0] then
                                    print "error with tempRfill";
                                    print "edge already labelled";
                                    read str;
                                end if;
                                flag:=true;
                                LabE(~labels,ctb,t[1], t[2], t[3], gens, invs, 
                                    ~newLabs, ~numLabd);
                            end if;
                        end while; 
                        M:=2;
                        while not(flag) and M lt (Ngens(G)*indH-numLabd) do
                        //try not-so-smart fill options
                            t:=addTemps(labels, numLabd, ctb, relWrds, gens,
                            invs, cycRels, newLabs, UnLabd, Hgens, M); 
                            if t[1] ne 0 then//success
                                if labels[t[1], t[2]] ne [0] then
                                    print "error with addTemps";
                                    print "edge already labelled";
                                    read str;
                                end if;
                                flag:=true;
                                LabE(~labels,ctb,t[1], t[2], t[3], gens, invs, 
                                    ~newLabs, ~numLabd);
                            else
                                M+:=1;
                            end if;
                        end while;
                        if not(flag) then//can't complete
                            print "unable to complete";
                            return labels, UnLabd;
                        end if;
                    end if;
                end while;
            end if;
        UnLabd:=[];//unlabd now contains Hgens whose label is not equal to
            //their number. this is needed for rewriting
        for i in [1..#Hgens1] do
            lab:=readWrd(Hgens[i],labels, ctb, gens, 1);
            if lab ne [i] then
                Append(~UnLabd, [*i, lab*]);
            end if;
        end for;
        //test
            for row in [1..#ctb] do
                for col in [1..#gens] do
                    for g in labels[row, col] do
                        if g eq 0 or g gt #Hgens or g lt -#Hgens then//error
                            print "invalid label found";
                            print "#Hgens=", #Hgens;
                            print labels[row,col];
                            read str;
                        end if;
                        break row;
                    end for;
                end for;
            end for;
        return labels, UnLabd;
    end function;

    getRels:=function(G,Hgens)
        //get labels
        labels, UnLabd:=CosGraphLabs(G, Hgens);
        //get gens
        gens:=[];
        for gen in Generators(G) do
            Append(~gens, gen);
        end for;
        //add inverses
        for gen in Generators(G) do
            Append(~gens, gen^-1);
        end for;
        invs:=[(Ngens(G)+1)..(2*Ngens(G))] cat [1..Ngens(G)];//gives inverse column
        //get relations of G
        Grels:=[LHS(w)*RHS(w)^-1 : w in Relations(G)];
        relWrds:=[];
        for rel in Grels do
            wrd:=writeWrd(rel, gens, invs, G);         
            Append(~relWrds, wrd);
        end for;
        H:=sub<G|Hgens>;
        ctb:=CosetTable(G,H);
        //find relations of H
        rels:=[];
        for cos in [1..#labels] do
            for word in relWrds do
                readout:=readWrd(word, labels, ctb, gens, cos);
                //cyclically reduce
                while #readout gt 1 and readout[1] eq -readout[#readout] do
                    Remove(~readout, 1);
                    Prune(~readout);
                end while;
                if #readout gt 0 and cycTest(rels, readout) then//new rel found
                    Append(~rels, readout);
                end if;
            end for;
        end for;
        //add relations for unlabelled generators
        for j in UnLabd do
            Append(~rels, [-j[1]] cat j[2]);
        end for;
        return rels;
    end function;

    /*reWrite2 (rewrite version 2)
        Uses CosGraphLabs to rewrite the subgroup of G generated by Hgens. 
        Returns a string giving a finite presentation for this group.
        This algorithm works faster than rewrite in many instances, 
        but tends not to give a very "pretty" presentation. 
        Use SimplifyLength(G) to get a prettier presentation.*/
    reWrite2:=function(G,Hgens)
        //get labels
        labels, UnLabd:=CosGraphLabs(G, Hgens);
        //get gens
        gens:=[];
        for gen in Generators(G) do
            Append(~gens, gen);
        end for;
        //add inverses
        for gen in Generators(G) do
            Append(~gens, gen^-1);
        end for;
        invs:=[(Ngens(G)+1)..(2*Ngens(G))] cat [1..Ngens(G)];//gives inverse column
        //get relations of G
        Grels:=[LHS(w)*RHS(w)^-1 : w in Relations(G)];
        relWrds:=[];
        for rel in Grels do
            wrd:=writeWrd(rel, gens, invs, G);         
            Append(~relWrds, wrd);
        end for;
        H:=sub<G|Hgens>;
        ctb:=CosetTable(G,H);
        //find relations of H
        rels:=[];
        for cos in [1..#labels] do
            for word in relWrds do
                readout:=readWrd(word, labels, ctb, gens, cos);
                //cyclically reduce
                while #readout gt 1 and readout[1] eq -readout[#readout] do
                    Remove(~readout, 1);
                    Prune(~readout);
                end while;
                if #readout gt 0 and cycTest(rels, readout) then//new rel found
                    Append(~rels, readout);
                end if;
            end for;
        end for;
        //convert rels to string
        Hrels:=[];
        for rel in rels do
            str:="";
            for g in [1..#rel-1] do
                if rel[g] lt 0 then
                    str cat:=alph[-rel[g]];
                    str cat:="^-1";
                else
                    str cat:=alph[rel[g]];
                end if;
                str cat:="* ";
            end for;
            g:=#rel;
            if rel[g] lt 0 then
                str cat:=alph[-rel[g]];
                str cat:="^-1";
            else
                str cat:=alph[rel[g]];
            end if;
            Append(~Hrels, str);
        end for;
        //add relations for unlabelled generators
        for j in UnLabd do
            rel:=j[2];
            str:=alph[j[1]];
            str *:="=";
            for g in [1..#rel-1] do
                if rel[g] lt 0 then
                    str cat:=alph[-rel[g]];
                    str cat:="^-1";
                else
                    str cat:=alph[rel[g]];
                end if;
                str cat:="* ";
            end for;
            g:=#rel;
            if rel[g] lt 0 then
                str cat:=alph[-rel[g]];
                str cat:="^-1";
            else
                str cat:=alph[rel[g]];
            end if;
            Append(~Hrels, str);
        end for;
        //print group
        str:="Group<";
        for i in [1..(#Hgens-1)] do
            str cat:=alph[i];
            str cat:= ",";
        end for;
        i:=#Hgens;
        str cat:=alph[i];
        str cat:="|";
        for j in [1..(#Hrels-1)] do
            str cat:=Hrels[j];
            str cat:=", ";
        end for;
        i:=#Hrels;
        str cat:=Hrels[i];
        str cat:=">,";
        return str;
    end function;

    /*getLab2 (get label version 2)
        use labelled coset graph to get a word for gen in the generators Hgens*/
    getLab2:=function(L, gen, G, ctb)
        gens:=[];
        for gen in Generators(G) do
            Append(~gens, gen);
        end for;
        //add inverses
        for gen in Generators(G) do
            Append(~gens, gen^-1);
        end for;
        invs:=[(Ngens(G)+1)..(2*Ngens(G))] cat [1..Ngens(G)];//gives inverse column
        str:="";//return value
        wrd:=writeWrd(gen, gens, invs, G);
        lab:=[];
        cos:=1;
        for g in wrd do
            lab:=simpCat(lab,L[cos, g]);
            cos:=ctb(cos, gens[g]);
        end for;
        if cos ne 1 then//error
            print "error";
            print gen, "not in subgroup";
            print "cos=", cos;
        end if;
        return lab;
    end function;
    
    /*getLabs (get labels)
        find a word for each element in wrds, find a word in terms of
        the elements of Hgens*/
    getLabs:=procedure(L,G, Hgens, wrds)
        H:=sub<G|Hgens>;
        ctb:=CosetTable(G,H); 
        for w in wrds do
            print w, "=", getLab2(L,w, G, ctb);
        end for;
    end procedure;

    /*getConjLabs(get conjugate labels)
        for each generator g of G and each subgroup generator h of Hgens
        we find a word for h^g in terms of the generators Hgens*/
    getConjLabs:=procedure(L,G, Hgens, set)
        H:=sub<G|Hgens>;
        ctb:=CosetTable(G,H); 
        conjs:=[[g^-1*Hgens[i]*g: g in set]: i in [1..#Hgens]];
        for i in [1..#Hgens] do
            rowSt:=Sprint(Hgens[i]);
            rowSt cat:= "=";
            rowSt cat:=IntegerToString(i);
            rowSt cat:=", ";
            for j in [1..#set] do
                rowSt cat:= Sprint(getLab2(L,conjs[i,j], G, ctb));
                rowSt cat:=", ";
            end for;
            rowSt:=rowSt[1..(#rowSt-2)];//remove last two chars
            print rowSt;
            //read str;//use this if the words are really long
        end for;
    end procedure;
/*end labelling*/
